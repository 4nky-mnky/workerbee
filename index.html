<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Workerbee by Achal-Aggarwal</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Workerbee</h1>
        <h2>A worker bee for your hive.</h2>

        <section id="downloads">
          <a href="https://github.com/Achal-Aggarwal/workerbee/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/Achal-Aggarwal/workerbee/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/Achal-Aggarwal/workerbee" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a id="workerbee" class="anchor" href="#workerbee" aria-hidden="true"><span class="octicon octicon-link"></span></a>Workerbee</h3>

<p>It’s a bee that could be used to perform various task with Apache Hive. Inspired from tools like Beetest, HiveRunner, hive_test.</p>

<h3>
<a id="schema-at-one-place" class="anchor" href="#schema-at-one-place" aria-hidden="true"><span class="octicon octicon-link"></span></a>Schema at one place</h3>

<p>Workerbee enables you to define schema of database and tables along side of Map - Reduce programs. Once written they can be managed by changing java code. Using MigrationGenerator, migrations can generated which can be run against the database that need to migrate.</p>

<h3>
<a id="que-ry-builder-at-disposal" class="anchor" href="#que-ry-builder-at-disposal" aria-hidden="true"><span class="octicon octicon-link"></span></a>Que## ry Builder at disposal</h3>

<p>Workerbee comes with basic query builder that comes handy when you don’t want to commit any typos while writing queries. No need to remember or lookup tables and their schema just to check column's order and type.</p>

<h3>
<a id="go-with-tdd" class="anchor" href="#go-with-tdd" aria-hidden="true"><span class="octicon octicon-link"></span></a>Go with TDD</h3>

<p>TDD is a wonderful approach to write minimal code required to do the work at hand. Workerbee allows you to write tests using unit test frameworks like JUnit. Using it you can formulate test for each case scenario and run it against setup data. Using data objects, created for each row of concerning table, more explicit assertions can made to get better assertion message on test failure.</p>

<h3>
<a id="domain-model-object-to-use-in-map-reduce-programs" class="anchor" href="#domain-model-object-to-use-in-map-reduce-programs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Domain model object to use in Map-Reduce programs</h3>

<p>When requirements gets complex and hive query could not handle it, writing map reduce program is a good option. But to read data and construct objects on which operations could be performed, knowledge of raw format or schema of the table is needed. Workerbee take care of this requirement, by extending Row of a table its behaviour could be extended.</p>

<h3>
<a id="supported-hive-version" class="anchor" href="#supported-hive-version" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supported Hive version</h3>

<p>Currently workerbee supports version VVVV, query builder doesn’t support everything that is in it.</p>

<h3>
<a id="example-scenario" class="anchor" href="#example-scenario" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example scenario</h3>

<p>With baseball statistics like bats man name, runs scored, the year for years 1871 - 2011, find the player with the highest runs for each year.</p>

<p><strong>Setting up project:</strong>
1. Clone the repo and build with <code>mvn install</code></p>

<ol>
<li><p>Add dependency 
<code>&lt;dependency&gt;</code>
<code>&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</code>
<code>&lt;artifactId&gt;lombok&lt;/artifactId&gt;</code>
<code>&lt;version&gt;1.16.4&lt;/version&gt;</code>
<code>&lt;scope&gt;provided&lt;/scope&gt;</code>
<code>&lt;/dependency&gt;</code></p></li>
<li><p>Add env variable HADOOP_HOME which points to your hadoop location</p></li>
</ol>

<p><strong>Creating Database &amp; table:</strong>
<code>public class BaseBall extends Database {</code>
  <code>public static final BaseBall db = new BaseBall();</code></p>

<p><code>private BaseBall() {</code>
    <code>super("BaseBall", "BaseBall database");</code>
  <code>}</code>
<code>}</code></p>

<p><code>public class Batting extends Table&lt;Batting&gt; {</code>
  <code>public static final Batting tb = new Batting();</code></p>

<p><code>public static final Column playerId = HavingColumn(tb, "player_id", Column.Type.STRING);</code>
  <code>public static final Column year = HavingColumn(tb, "year", Column.Type.INT);</code>
  <code>public static final Column runs = HavingColumn(tb, "runs", Column.Type.INT);</code></p>

<p><code>private Batting() {</code>
    <code>super(BaseBall.db, "Batting", "Batting table", 1);</code>
  <code>}</code>
<code>}</code></p>

<p><strong>Writing Test - Using Junit4:</strong>
<code>public class PlayerWithHighestRunForEachYear() {</code>
  <code>public static final String PLAYER_1_ID = "PLAYER1_ID";</code>
  <code>public static final String PLAYER_2_ID = "PLAYER2_ID";</code>
  <code>public static final String PLAYER_3_ID = "PLAYER3_ID";</code>
  <code>private Repository repo;</code>
  <code>private Row&lt;Batting&gt; lowestRun</code>
    <code>= Batting.tb.getNewRow()</code>
    <code>.set(Batting.playerId, PLAYER_1_ID)</code>
    <code>.set(Batting.year, 1990)</code>
    <code>.set(Batting.runs, 10);</code></p>

<p><code>private Row&lt;Batting&gt; mediumRun</code>
    <code>= Batting.tb.getNewRow()</code>
    <code>.set(Batting.playerId, PLAYER_2_ID)</code>
    <code>.set(Batting.year, 1990)</code>
    <code>.set(Batting.runs, 100);</code></p>

<p><code>private Row&lt;Batting&gt; maximumRun</code>
    <code>= Batting.tb.getNewRow()</code>
    <code>.set(Batting.playerId, PLAYER_3_ID)</code>
    <code>.set(Batting.year, 2000)</code>
    <code>.set(Batting.runs, 50);</code></p>

<p><code>public BaseBallTest() throws IOException, SQLException {</code>
    <code>repo = Repository.TemporaryRepository();</code>
    <code>repo.execute(create(BaseBall.db).ifNotExist());</code>
  <code>}</code></p>

<p><code>@Test</code>
  <code>public void shouldReturnPlayerWithHighestScoreForEachYear() throws IOException, SQLException {</code>
    <code>repo.setUp(Batting.tb);</code>
    <code>repo.setUp(Batting.tb)</code>
      <code>.setUp(Batting.tb, lowestRun, mediumRun, maximumRun);</code></p>

<pre><code>`SelectQuery selectQuery = select(Batting.year, max(Batting.runs))`
  `.from(Batting.tb)`
  `.groupBy(Batting.year)`
  `.ascOrderOf(Batting.year)`
  `.as("MaxRunsForEachYear");`

`Table&lt;Table&gt; maxRunsForEachYear = selectQuery.table();`

`List&lt;Row&lt;Table&gt;&gt; years = repo.execute(QUERY_TO_TEST);`

`assertThat(years.size(), is(2));`

`assertThat(years.get(0).getString(Batting.playerId), is(PLAYER_2_ID));`
`assertThat(years.get(0).getInt(Batting.year), is(1990));`
`assertThat(years.get(0).getInt(Batting.runs), is(100));`

`assertThat(years.get(1).getString(Batting.playerId), is(PLAYER_3_ID));`
`assertThat(years.get(1).getInt(Batting.year), is(2000));`
`assertThat(years.get(1).getInt(Batting.runs), is(50));`
</code></pre>

<p><code>}</code>
<code>}</code></p>

<p><strong>Writing queries</strong>
The next step is to group the data by year so we can find the highest score for each year. This query first groups all the records by year and then selects the player with the highest runs from each year.</p>

<p><code>select(Batting.year, max(Batting.runs))</code>
  <code>.from(Batting.tb)</code>
  <code>.groupBy(Batting.year)</code></p>

<p>Now we need to go back and get the player_id(s) so we know who the player(s) was. We know that for a given year we can use the runs to find the player(s) for that year. So we can take the previous query and join it with the batting records to get the final table.</p>

<p><code>SelectQuery selectQuery = select(Batting.year, max(Batting.runs))</code>
  <code>.from(Batting.tb)</code>
  <code>.groupBy(Batting.year)</code>
  <code>.ascOrderOf(Batting.year)</code>
  <code>.as("MaxRunsForEachYear");</code></p>

<p><code>Table&lt;Table&gt; maxRunsForEachYear = selectQuery.table();</code></p>

<p><code>select(Batting.playerId, Batting.year, Batting.runs).from(Batting.tb)</code>
  <code>.join(selectQuery)</code>
  <code>.on(Batting.year.eq(maxRunsForEachYear.getColumn(Batting.year))</code>
      <code>.and(Batting.runs.eq(maxRunsForEachYear.getColumn(Batting.runs)))</code>
  <code>)</code></p>
      </section>
    </div>

    
  </body>
</html>
