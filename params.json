{"name":"Workerbee","tagline":"A worker bee for your hive.","body":"### Workerbee\r\nIt’s a bee that could be used to perform various task with Apache Hive. Inspired from tools like Beetest, HiveRunner, hive_test.\r\n\r\n### Schema at one place\r\nWorkerbee enables you to define schema of database and tables along side of Map - Reduce programs. Once written they can be managed by changing java code. Using MigrationGenerator, migrations can generated which can be run against the database that need to migrate.\r\n\r\n### Query Builder at disposal\r\nWorkerbee comes with basic query builder that comes handy when you don’t want to commit any typos while writing queries. No need to remember or lookup tables and their schema just to check column's order and type.\r\n\r\n### Go with TDD\r\nTDD is a wonderful approach to write minimal code required to do the work at hand. Workerbee allows you to write tests using unit test frameworks like JUnit. Using it you can formulate test for each case scenario and run it against setup data. Using data objects, created for each row of concerning table, more explicit assertions can made to get better assertion message on test failure.\r\n\r\n### Domain model object to use in Map-Reduce programs\r\nWhen requirements gets complex and hive query could not handle it, writing map reduce program is a good option. But to read data and construct objects on which operations could be performed, knowledge of raw format or schema of the table is needed. Workerbee take care of this requirement, by extending Row of a table its behaviour could be extended.\r\n\r\n### Supported Hive version\r\nCurrently workerbee supports hive version 0.13, query builder doesn’t support everything that is in it, yet.\r\n\r\n### Example scenario\r\nWith baseball statistics like bats man name, runs scored, the year for years 1871 - 2011, find the player with the highest runs for each year.\r\n\r\n**Setting up project:**\r\n\r\nI. Clone the repo and build with mvn install\r\nII. Add dependency \r\n```xml\r\n<dependency>\r\n   <groupId>com.workerbee</groupId>\r\n   <artifactId>workerbee-core</artifactId>\r\n   <version>1.0-SNAPSHOT</version>\r\n</dependency>\r\n```\r\nIII. Add env variable HADOOP_HOME which points to your hadoop location\r\n\r\n**Creating Database & table:**\r\n```java\r\npublic class BaseBall extends Database {\r\n  public static final BaseBall db = new BaseBall();\r\n\r\n  private BaseBall() {\r\n    super(\"BaseBall\", \"BaseBall database\");\r\n  }\r\n}\r\n\r\npublic class Batting extends Table<Batting> {\r\n  public static final Batting tb = new Batting();\r\n\r\n  public static final Column playerId = HavingColumn(tb, \"player_id\", Column.Type.STRING);\r\n  public static final Column year = HavingColumn(tb, \"year\", Column.Type.INT);\r\n  public static final Column runs = HavingColumn(tb, \"runs\", Column.Type.INT);\r\n\r\n  private Batting() {\r\n    super(BaseBall.db, \"Batting\", \"Batting table\", 1);\r\n  }\r\n}\r\n```\r\n\r\n**Writing Test - Using Junit4:**\r\n```java\r\npublic class PlayerWithHighestRunForEachYear() {\r\n  public static final String PLAYER_1_ID = \"PLAYER1_ID\";\r\n  public static final String PLAYER_2_ID = \"PLAYER2_ID\";\r\n  public static final String PLAYER_3_ID = \"PLAYER3_ID\";\r\n  private Repository repo;\r\n  private Row<Batting> lowestRun\r\n    = Batting.tb.getNewRow()\r\n    .set(Batting.playerId, PLAYER_1_ID)\r\n    .set(Batting.year, 1990)\r\n    .set(Batting.runs, 10);\r\n\r\n  private Row<Batting> mediumRun\r\n    = Batting.tb.getNewRow()\r\n    .set(Batting.playerId, PLAYER_2_ID)\r\n    .set(Batting.year, 1990)\r\n    .set(Batting.runs, 100);\r\n\r\n  private Row<Batting> maximumRun\r\n    = Batting.tb.getNewRow()\r\n    .set(Batting.playerId, PLAYER_3_ID)\r\n    .set(Batting.year, 2000)\r\n    .set(Batting.runs, 50);\r\n\r\n  public BaseBallTest() throws IOException, SQLException {\r\n    repo = Repository.TemporaryRepository();\r\n    repo.execute(create(BaseBall.db).ifNotExist());\r\n  }\r\n\r\n  @Test\r\n  public void shouldReturnPlayerWithHighestScoreForEachYear() throws IOException, SQLException {\r\n    repo.setUp(Batting.tb);\r\n    repo.setUp(Batting.tb)\r\n      .setUp(Batting.tb, lowestRun, mediumRun, maximumRun);\r\n\r\n    SelectQuery selectQuery = select(Batting.year, max(Batting.runs))\r\n      .from(Batting.tb)\r\n      .groupBy(Batting.year)\r\n      .ascOrderOf(Batting.year)\r\n      .as(\"MaxRunsForEachYear\");\r\n\r\n    Table<Table> maxRunsForEachYear = selectQuery.table();\r\n\r\n    List<Row<Table>> years = repo.execute(QUERY_TO_TEST);\r\n\r\n    assertThat(years.size(), is(2));\r\n\r\n    assertThat(years.get(0).getString(Batting.playerId), is(PLAYER_2_ID));\r\n    assertThat(years.get(0).getInt(Batting.year), is(1990));\r\n    assertThat(years.get(0).getInt(Batting.runs), is(100));\r\n\r\n    assertThat(years.get(1).getString(Batting.playerId), is(PLAYER_3_ID));\r\n    assertThat(years.get(1).getInt(Batting.year), is(2000));\r\n    assertThat(years.get(1).getInt(Batting.runs), is(50));\r\n  }\r\n}\r\n```\r\n**Writing queries**\r\nThe next step is to group the data by year so we can find the highest score for each year. This query first groups all the records by year and then selects the player with the highest runs from each year.\r\n```java\r\nselect(Batting.year, max(Batting.runs))\r\n  .from(Batting.tb)\r\n  .groupBy(Batting.year)\r\n```\r\nNow we need to go back and get the player_id(s) so we know who the player(s) was. We know that for a given year we can use the runs to find the player(s) for that year. So we can take the previous query and join it with the batting records to get the final table.\r\n```java\r\nSelectQuery selectQuery = select(Batting.year, max(Batting.runs))\r\n  .from(Batting.tb)\r\n  .groupBy(Batting.year)\r\n  .ascOrderOf(Batting.year)\r\n  .as(\"MaxRunsForEachYear\");\r\n\r\nTable<Table> maxRunsForEachYear = selectQuery.table();\r\n\r\nselect(Batting.playerId, Batting.year, Batting.runs).from(Batting.tb)\r\n  .join(selectQuery)\r\n  .on(Batting.year.eq(maxRunsForEachYear.getColumn(Batting.year))\r\n      .and(Batting.runs.eq(maxRunsForEachYear.getColumn(Batting.runs)))\r\n  )\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}